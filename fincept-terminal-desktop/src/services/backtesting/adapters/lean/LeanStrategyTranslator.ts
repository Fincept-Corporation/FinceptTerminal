/**
 * Lean Strategy Translator
 *
 * Translates platform-independent StrategyDefinition to Lean Python code.
 * Handles code, visual (node editor), and template-based strategies.
 */

import { StrategyDefinition } from '../../interfaces/IStrategyDefinition';
import { LeanStrategyTemplate } from './types';

/**
 * LeanStrategyTranslator
 *
 * Converts generic strategy definitions to Lean-compatible Python code.
 */
export class LeanStrategyTranslator {
  /**
   * Translate StrategyDefinition to Lean Python code
   */
  translate(strategy: StrategyDefinition): string {
    switch (strategy.type) {
      case 'code':
        return this.translateCodeStrategy(strategy);
      case 'visual':
        return this.translateVisualStrategy(strategy);
      case 'template':
        return this.translateTemplateStrategy(strategy);
      default:
        throw new Error(`Unknown strategy type: ${strategy.type}`);
    }
  }

  /**
   * Translate code-based strategy
   *
   * For code strategies, we wrap the user's Python code in a Lean QCAlgorithm class
   * if it's not already wrapped.
   */
  private translateCodeStrategy(strategy: StrategyDefinition): string {
    if (!strategy.code || strategy.code.language !== 'python') {
      throw new Error('Code strategy must have Python code');
    }

    const userCode = strategy.code.source;

    // Check if code already defines a QCAlgorithm class
    if (userCode.includes('class') && userCode.includes('QCAlgorithm')) {
      // User provided complete Lean algorithm, use as-is
      return this.addStrategyMetadata(userCode, strategy);
    }

    // Otherwise, wrap in a basic QCAlgorithm template
    return this.wrapInQCAlgorithm(userCode, strategy);
  }

  /**
   * Translate visual (node-based) strategy
   *
   * Generates Lean Python code from node editor graph.
   */
  private translateVisualStrategy(strategy: StrategyDefinition): string {
    if (!strategy.visual) {
      throw new Error('Visual strategy must have visual definition');
    }

    // If already generated, use that
    if (strategy.visual.generatedPython) {
      return this.wrapInQCAlgorithm(strategy.visual.generatedPython, strategy);
    }

    // Otherwise, generate from nodes
    const generatedCode = this.generateFromNodes(strategy.visual.nodes, strategy.visual.edges);
    return this.wrapInQCAlgorithm(generatedCode, strategy);
  }

  /**
   * Translate template-based strategy
   *
   * Fills in a pre-built template with user parameters.
   */
  private translateTemplateStrategy(strategy: StrategyDefinition): string {
    if (!strategy.template) {
      throw new Error('Template strategy must have template definition');
    }

    // Load template (templates would be stored in a registry)
    const template = this.loadTemplate(strategy.template.templateId);

    // Replace parameters
    const filledCode = this.fillTemplate(template.pythonCode, strategy.template.parameters);

    return this.addStrategyMetadata(filledCode, strategy);
  }

  /**
   * Wrap user code in QCAlgorithm class structure
   */
  private wrapInQCAlgorithm(userCode: string, strategy: StrategyDefinition): string {
    const className = this.sanitizeClassName(strategy.name);

    return `
# ==============================================================================
# Lean Algorithm: ${strategy.name}
# Version: ${strategy.version}
# Author: ${strategy.author}
# Description: ${strategy.description}
# Generated by Fincept Terminal
# ==============================================================================

from AlgorithmImports import *

class ${className}(QCAlgorithm):
    """
    ${strategy.description}
    """

    def Initialize(self):
        """Initialize algorithm settings and data subscriptions"""

        # Set date range (will be overridden by CLI args)
        self.SetStartDate(${this.formatDateForLean(strategy.requires.startDate || '2020-01-01')})
        self.SetEndDate(${this.formatDateForLean(strategy.requires.endDate || new Date().toISOString())})

        # Set initial capital
        self.SetCash(${strategy.requires.capital})

        # Set brokerage model
        ${this.getBrokerageModel(strategy)}

        # Subscribe to data
        ${this.generateDataSubscriptions(strategy)}

        # User initialization code
        ${this.indentCode(userCode, 2)}

    def OnData(self, data):
        """Event handler for data updates"""
        # User OnData logic would be extracted from userCode
        # For now, pass to user-defined methods
        pass

    def OnEndOfAlgorithm(self):
        """Called at the end of the algorithm"""
        self.Debug(f"Algorithm completed: {self.Portfolio.TotalPortfolioValue}")

# ==============================================================================
# End of Algorithm
# ==============================================================================
`.trim();
  }

  /**
   * Generate code from visual nodes
   *
   * This is a simplified version - full implementation would traverse the node graph
   * and generate appropriate code for each node type.
   */
  private generateFromNodes(nodes: any[], edges: any[]): string {
    const codeLines: string[] = [];

    // Sort nodes by execution order (based on edges)
    const sortedNodes = this.topologicalSort(nodes, edges);

    for (const node of sortedNodes) {
      switch (node.type) {
        case 'dataSource':
          codeLines.push(this.generateDataSourceCode(node));
          break;
        case 'indicator':
          codeLines.push(this.generateIndicatorCode(node));
          break;
        case 'condition':
          codeLines.push(this.generateConditionCode(node));
          break;
        case 'signal':
          codeLines.push(this.generateSignalCode(node));
          break;
        case 'order':
          codeLines.push(this.generateOrderCode(node));
          break;
        default:
          codeLines.push(`# Unknown node type: ${node.type}`);
      }
    }

    return codeLines.join('\n\n');
  }

  /**
   * Generate data subscription code
   */
  private generateDataSubscriptions(strategy: StrategyDefinition): string {
    const subscriptions: string[] = [];

    if (strategy.requires.assets) {
      for (const asset of strategy.requires.assets) {
        const symbol = asset.symbol;
        const resolution = this.getLeanResolution('daily'); // Use default as asset doesn't have timeframe

        subscriptions.push(
          `self.AddEquity("${symbol}", ${resolution})`
        );
      }
    }

    return subscriptions.join('\n        ');
  }

  /**
   * Get Lean brokerage model
   */
  private getBrokerageModel(strategy: StrategyDefinition): string {
    // Default to simulation for backtesting
    return 'self.SetBrokerageModel(BrokerageName.Default)';
  }

  /**
   * Convert timeframe to Lean resolution
   */
  private getLeanResolution(timeframe: string): string {
    const map: Record<string, string> = {
      'tick': 'Resolution.Tick',
      'second': 'Resolution.Second',
      'minute': 'Resolution.Minute',
      'hour': 'Resolution.Hour',
      'daily': 'Resolution.Daily',
    };
    return map[timeframe] || 'Resolution.Daily';
  }

  /**
   * Format date for Lean (year, month, day)
   */
  private formatDateForLean(isoDate: string): string {
    const date = new Date(isoDate);
    return `${date.getFullYear()}, ${date.getMonth() + 1}, ${date.getDate()}`;
  }

  /**
   * Sanitize class name (remove special chars, spaces)
   */
  private sanitizeClassName(name: string): string {
    return name
      .replace(/[^a-zA-Z0-9]/g, '_')
      .replace(/^[0-9]/, '_$&')
      .replace(/_+/g, '_');
  }

  /**
   * Add metadata comments to existing code
   */
  private addStrategyMetadata(code: string, strategy: StrategyDefinition): string {
    const metadata = `
# ==============================================================================
# Strategy: ${strategy.name}
# Version: ${strategy.version}
# Author: ${strategy.author}
# Description: ${strategy.description}
# Generated by Fincept Terminal
# ==============================================================================

`.trim();

    return metadata + '\n\n' + code;
  }

  /**
   * Indent code by specified levels (2 spaces per level)
   */
  private indentCode(code: string, levels: number): string {
    const indent = '  '.repeat(levels);
    return code
      .split('\n')
      .map((line) => (line.trim() ? indent + line : line))
      .join('\n');
  }

  /**
   * Topological sort for node execution order
   */
  private topologicalSort(nodes: any[], edges: any[]): any[] {
    // Simplified - just return nodes in order for now
    // Full implementation would do proper topological sort based on edges
    return [...nodes];
  }

  /**
   * Generate code for data source node
   */
  private generateDataSourceCode(node: any): string {
    const symbol = node.data.symbol;
    const resolution = this.getLeanResolution(node.data.timeframe || 'daily');
    return `self.${node.id} = self.AddEquity("${symbol}", ${resolution})`;
  }

  /**
   * Generate code for indicator node
   */
  private generateIndicatorCode(node: any): string {
    const indicator = node.data.indicator;
    const period = node.data.period;
    const symbol = node.data.symbol;

    return `self.${node.id} = self.${indicator}("${symbol}", ${period})`;
  }

  /**
   * Generate code for condition node
   */
  private generateConditionCode(node: any): string {
    const condition = node.data.condition;
    return `# Condition: ${condition}`;
  }

  /**
   * Generate code for signal node
   */
  private generateSignalCode(node: any): string {
    const signal = node.data.signal;
    return `# Signal: ${signal}`;
  }

  /**
   * Generate code for order node
   */
  private generateOrderCode(node: any): string {
    const action = node.data.action;
    const symbol = node.data.symbol;
    const quantity = node.data.quantity;

    return `self.${action}("${symbol}", ${quantity})`;
  }

  /**
   * Load template by ID (stub - would load from registry)
   */
  private loadTemplate(templateId: string): LeanStrategyTemplate {
    // This would load from a template registry
    // For now, return a stub
    throw new Error(`Template ${templateId} not found`);
  }

  /**
   * Fill template with parameters
   */
  private fillTemplate(template: string, params: Record<string, any>): string {
    let filled = template;

    for (const [key, value] of Object.entries(params)) {
      const placeholder = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
      filled = filled.replace(placeholder, String(value));
    }

    return filled;
  }

  /**
   * Validate generated Lean code (basic syntax check)
   */
  validate(pythonCode: string): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check for required imports
    if (!pythonCode.includes('QCAlgorithm')) {
      errors.push('Code must define or import QCAlgorithm');
    }

    // Check for Initialize method
    if (!pythonCode.includes('def Initialize')) {
      errors.push('Algorithm must have Initialize method');
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }
}
