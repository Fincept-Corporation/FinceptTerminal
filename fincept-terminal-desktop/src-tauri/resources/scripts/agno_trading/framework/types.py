"""
Core types for the Alpha Arena trading framework.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Literal
from enum import Enum
from datetime import datetime


class Side(str, Enum):
    """Trade side."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class TxStatus(str, Enum):
    """Transaction status."""
    FILLED = "FILLED"
    REJECTED = "REJECTED"
    PENDING = "PENDING"
    CANCELLED = "CANCELLED"


class TradingMode(str, Enum):
    """Trading mode."""
    PAPER = "PAPER"
    LIVE = "LIVE"


@dataclass
class TradeInstruction:
    """
    Instruction to execute a trade.
    Generated by composer, consumed by execution gateway.
    """
    symbol: str
    side: Side
    quantity: float
    leverage: float = 1.0
    max_slippage_bps: int = 50  # 0.5%
    model_name: Optional[str] = None  # For multi-model competitions
    reasoning: Optional[str] = None
    confidence: Optional[float] = None


@dataclass
class TxResult:
    """
    Result of a trade execution.
    Returned by execution gateway, consumed by portfolio service.
    """
    instruction: TradeInstruction
    status: TxStatus
    fill_price: Optional[float] = None
    fill_quantity: Optional[float] = None
    fee: float = 0.0
    notional: float = 0.0
    timestamp_ms: int = 0
    error_message: Optional[str] = None

    def to_dict(self) -> dict:
        return {
            "symbol": self.instruction.symbol,
            "side": self.instruction.side.value,
            "quantity": self.fill_quantity or 0.0,
            "price": self.fill_price or 0.0,
            "fee": self.fee,
            "notional": self.notional,
            "status": self.status.value,
            "model_name": self.instruction.model_name,
            "reasoning": self.instruction.reasoning,
            "confidence": self.instruction.confidence,
            "timestamp_ms": self.timestamp_ms,
        }


@dataclass
class PositionSnapshot:
    """Snapshot of a single position."""
    symbol: str
    quantity: float
    avg_entry_price: float
    current_price: float
    unrealized_pnl: float
    leverage: float = 1.0
    side: Side = Side.BUY


@dataclass
class PortfolioView:
    """
    Complete portfolio state at a point in time.
    Returned by portfolio service.
    """
    cash: float
    positions: Dict[str, PositionSnapshot]
    total_value: float
    total_unrealized_pnl: float
    total_realized_pnl: float
    gross_exposure: float
    net_exposure: float
    trades_count: int = 0

    def to_dict(self) -> dict:
        return {
            "cash": self.cash,
            "positions": {
                sym: {
                    "symbol": pos.symbol,
                    "quantity": pos.quantity,
                    "avg_entry_price": pos.avg_entry_price,
                    "current_price": pos.current_price,
                    "unrealized_pnl": pos.unrealized_pnl,
                    "leverage": pos.leverage,
                    "side": pos.side.value,
                }
                for sym, pos in self.positions.items()
            },
            "total_value": self.total_value,
            "total_unrealized_pnl": self.total_unrealized_pnl,
            "total_realized_pnl": self.total_realized_pnl,
            "gross_exposure": self.gross_exposure,
            "net_exposure": self.net_exposure,
            "trades_count": self.trades_count,
        }


@dataclass
class Candle:
    """OHLCV candle."""
    timestamp: int  # Unix timestamp in milliseconds
    open: float
    high: float
    low: float
    close: float
    volume: float


@dataclass
class MarketSnapshot:
    """Real-time market snapshot for a symbol."""
    symbol: str
    last_price: float
    bid: float
    ask: float
    volume_24h: float
    high_24h: float
    low_24h: float
    change_24h_pct: float
    timestamp_ms: int


@dataclass
class FeatureVector:
    """
    Feature vector for a symbol at a point in time.
    Contains price data and technical indicators.
    """
    symbol: str
    timestamp_ms: int

    # Price data
    close: float
    open: float
    high: float
    low: float
    volume: float

    # Market snapshot
    bid: float
    ask: float
    spread_bps: float

    # Technical indicators
    rsi_14: Optional[float] = None
    macd: Optional[float] = None
    macd_signal: Optional[float] = None
    macd_histogram: Optional[float] = None
    bb_upper: Optional[float] = None
    bb_middle: Optional[float] = None
    bb_lower: Optional[float] = None
    atr_14: Optional[float] = None

    # Volatility
    volatility_24h: Optional[float] = None

    def to_dict(self) -> dict:
        return {
            "symbol": self.symbol,
            "timestamp_ms": self.timestamp_ms,
            "close": self.close,
            "open": self.open,
            "high": self.high,
            "low": self.low,
            "volume": self.volume,
            "bid": self.bid,
            "ask": self.ask,
            "spread_bps": self.spread_bps,
            "rsi_14": self.rsi_14,
            "macd": self.macd,
            "macd_signal": self.macd_signal,
            "macd_histogram": self.macd_histogram,
            "bb_upper": self.bb_upper,
            "bb_middle": self.bb_middle,
            "bb_lower": self.bb_lower,
            "atr_14": self.atr_14,
            "volatility_24h": self.volatility_24h,
        }


@dataclass
class FeaturesResult:
    """Result from features pipeline."""
    features: List[FeatureVector]
    timestamp_ms: int
    lookback_periods: int


@dataclass
class TradeDigestEntry:
    """Performance digest for a single symbol."""
    symbol: str
    trade_count: int
    realized_pnl: float
    win_rate: float
    avg_holding_ms: int
    last_trade_ts: int


@dataclass
class TradeDigest:
    """
    Performance digest across all trading.
    Used to inform LLM of historical performance.
    """
    total_trades: int
    total_realized_pnl: float
    overall_win_rate: float
    sharpe_ratio: float
    max_drawdown: float
    by_instrument: Dict[str, TradeDigestEntry]

    def to_dict(self) -> dict:
        return {
            "total_trades": self.total_trades,
            "total_realized_pnl": self.total_realized_pnl,
            "overall_win_rate": self.overall_win_rate,
            "sharpe_ratio": self.sharpe_ratio,
            "max_drawdown": self.max_drawdown,
            "by_instrument": {
                sym: {
                    "symbol": entry.symbol,
                    "trade_count": entry.trade_count,
                    "realized_pnl": entry.realized_pnl,
                    "win_rate": entry.win_rate,
                    "avg_holding_ms": entry.avg_holding_ms,
                }
                for sym, entry in self.by_instrument.items()
            },
        }


@dataclass
class ComposeContext:
    """
    Context provided to composer for decision making.
    Contains all information needed to make a trading decision.
    """
    ts: int  # Current timestamp in milliseconds
    compose_id: str  # Unique ID for this decision cycle
    strategy_id: str  # Competition/strategy ID
    model_name: str  # Model making the decision

    # Market data
    features: List[FeatureVector]

    # Portfolio state
    portfolio: PortfolioView

    # Historical performance
    digest: Optional[TradeDigest] = None

    # Custom prompt/instructions
    custom_prompt: Optional[str] = None


@dataclass
class ComposeResult:
    """
    Result from composer.
    Contains trade instructions to execute.
    """
    instructions: List[TradeInstruction]
    compose_id: str
    model_name: str
    rationale: Optional[str] = None
    decision_type: Optional[str] = None  # BUY, SELL, HOLD, or WAIT
    metadata: Dict = field(default_factory=dict)


@dataclass
class DecisionCycleResult:
    """
    Complete result of a decision cycle.
    Includes decisions, executions, and updated portfolio.
    """
    cycle_id: str
    cycle_number: int
    timestamp_ms: int

    # Decisions from all models
    compose_results: List[ComposeResult]

    # Execution results
    tx_results: List[TxResult]

    # Updated portfolio snapshots (per model)
    portfolio_snapshots: Dict[str, PortfolioView]

    # Performance metrics
    leaderboard: List[Dict]  # Rankings by P&L

    def to_dict(self) -> dict:
        return {
            "cycle_id": self.cycle_id,
            "cycle_number": self.cycle_number,
            "timestamp_ms": self.timestamp_ms,
            "compose_results": [
                {
                    "compose_id": cr.compose_id,
                    "model_name": cr.model_name,
                    "instructions": [
                        {
                            "symbol": inst.symbol,
                            "side": inst.side.value,
                            "quantity": inst.quantity,
                            "leverage": inst.leverage,
                            "reasoning": inst.reasoning,
                            "confidence": inst.confidence,
                        }
                        for inst in cr.instructions
                    ],
                    "rationale": cr.rationale,
                }
                for cr in self.compose_results
            ],
            "tx_results": [tx.to_dict() for tx in self.tx_results],
            "portfolio_snapshots": {
                model: snapshot.to_dict()
                for model, snapshot in self.portfolio_snapshots.items()
            },
            "leaderboard": self.leaderboard,
        }
