#!/usr/bin/env python
"""
Agno Trading Service - Main Entry Point
========================================

This service is called from Rust/Tauri commands and provides a unified interface
to the Agno trading agent system.

Usage from Rust:
    execute_python_command(&app, "agno_trading_service.py", &["command", "arg1", "arg2", ...])

Commands:
    - create_agent: Create a new trading agent
    - run_agent: Execute an agent with a prompt
    - create_team: Create a team of agents
    - run_team: Execute a team task
    - list_models: List available LLM models
    - get_agent_status: Get agent execution status
    - analyze_market: Run market analysis
    - generate_trade_signal: Generate trading signals
    - manage_risk: Run risk management analysis
"""

import sys
import json
import os
import logging
from datetime import datetime
from typing import Dict, Any, Optional, List

# Configure logging to output to stderr only (stdout is reserved for JSON responses)
logging.basicConfig(
    level=logging.ERROR,
    format='%(levelname)s: %(message)s',
    stream=sys.stderr,
    force=True
)

# Redirect all prints and logs to stderr to prevent breaking JSON output
class StdoutToStderr:
    def write(self, text):
        sys.stderr.write(text)
    def flush(self):
        sys.stderr.flush()

# Save original stdout
_original_stdout = sys.stdout

def _suppress_stdout():
    """Suppress stdout during operations"""
    sys.stdout = StdoutToStderr()

def _restore_stdout():
    """Restore original stdout"""
    sys.stdout = _original_stdout

# Suppress by default (will restore only for JSON output)
_suppress_stdout()
# Agno uses loguru which outputs to stdout - we need to disable it
os.environ['LOGURU_LEVEL'] = 'CRITICAL'
os.environ['LOGURU_AUTOINIT'] = 'False'

# Add agno_trading to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'agno_trading'))

# Disable loguru after import
try:
    from loguru import logger
    logger.remove()  # Remove all default handlers
    logger.add(sys.stderr, level="CRITICAL")  # Only critical errors to stderr
except ImportError:
    pass

# Import after path is set
from agno_trading.config.settings import AgnoConfig, LLMConfig, LLMProvider, TradingConfig, TradingMode
from agno_trading.config.models import list_available_models, get_best_model_for_task, validate_model_config
from agno_trading.core.agent_manager import get_agent_manager, AgentConfig as CoreAgentConfig
from agno_trading.agents.market_analyst import MarketAnalystAgent
from agno_trading.agents.trading_strategy import TradingStrategyAgent
from agno_trading.agents.risk_manager import RiskManagerAgent
from agno_trading.agents.portfolio_manager import PortfolioManagerAgent

# Global orchestrator and manager instances to persist state across commands
_global_orchestrator = None
_global_manager = None

def get_global_orchestrator():
    """Get or create global TeamOrchestrator instance"""
    global _global_orchestrator
    if _global_orchestrator is None:
        from agno_trading.core.team_orchestrator import TeamOrchestrator
        _global_orchestrator = TeamOrchestrator()
    return _global_orchestrator

def get_global_manager():
    """Get or create global AgentManager instance"""
    global _global_manager
    if _global_manager is None:
        from agno_trading.core.agent_manager import AgentManager
        _global_manager = AgentManager()
    return _global_manager


def create_response(success: bool, data: Any = None, error: str = None) -> str:
    """Create standardized JSON response"""
    response = json.dumps({
        "success": success,
        "data": data,
        "error": error
    }, indent=2)

    # Restore stdout to print JSON response
    _restore_stdout()
    return response


def list_models_command(provider: Optional[str] = None) -> str:
    """List available LLM models"""
    try:
        models = list_available_models(provider)
        return create_response(True, {"models": models})
    except Exception as e:
        return create_response(False, error=str(e))


def recommend_model_command(task: str, budget: str = "medium", reasoning: bool = False) -> str:
    """Recommend best model for a task"""
    try:
        provider, model = get_best_model_for_task(task, budget, reasoning)
        return create_response(True, {
            "provider": provider,
            "model": model,
            "model_string": f"{provider}:{model}"
        })
    except Exception as e:
        return create_response(False, error=str(e))


def validate_config_command(config_json: str) -> str:
    """Validate an Agno configuration"""
    try:
        config_dict = json.loads(config_json)

        # Create LLM config
        llm_data = config_dict.get("llm", {})
        llm_config = LLMConfig(
            provider=LLMProvider(llm_data.get("provider", "openai")),
            model=llm_data.get("model", "gpt-4"),
            temperature=llm_data.get("temperature", 0.7),
            max_tokens=llm_data.get("max_tokens"),
            stream=llm_data.get("stream", False),
            reasoning_effort=llm_data.get("reasoning_effort")
        )

        # Validate
        is_valid, error_msg = validate_model_config(llm_config)

        return create_response(is_valid, {"valid": is_valid}, error_msg)
    except Exception as e:
        return create_response(False, error=str(e))


def create_agent_command(agent_config_json: str) -> str:
    """Create a new trading agent"""
    try:
        config_dict = json.loads(agent_config_json)

        # Parse model string (format: "provider:model")
        agent_model = config_dict.get("agent_model", "openai:gpt-4o-mini")
        if ":" in agent_model:
            model_provider, model_name = agent_model.split(":", 1)
        else:
            model_provider = "openai"
            model_name = agent_model

        # Create agent configuration
        agent_config = CoreAgentConfig(
            name=config_dict.get("name", "Agent"),
            role=config_dict.get("role", "Trading Agent"),
            description=config_dict.get("description", "AI Trading Agent"),
            instructions=config_dict.get("instructions", []),
            model_provider=model_provider,
            model_name=model_name,
            temperature=config_dict.get("temperature", 0.7),
            tools=config_dict.get("tools", ["market_data", "technical_analysis"]),
            symbols=config_dict.get("symbols", ["BTC/USD"]),
            enable_memory=config_dict.get("enable_memory", True)
        )

        # Create agent via agent manager
        manager = get_agent_manager()
        agent_id = manager.create_agent(agent_config)

        return create_response(True, {
            "agent_id": agent_id,
            "status": "created",
            "config": {
                "name": agent_config.name,
                "role": agent_config.role,
                "model": f"{model_provider}:{model_name}"
            }
        })
    except Exception as e:
        return create_response(False, error=str(e))


def run_agent_command(agent_id: str, prompt: str, session_id: Optional[str] = None) -> str:
    """Run an agent with a prompt"""
    try:
        # Get agent manager and run the agent
        manager = get_agent_manager()
        result = manager.run_agent(agent_id, prompt, session_id)

        return create_response(True, result)
    except Exception as e:
        return create_response(False, error=str(e))


def analyze_market_command(
    symbol: str,
    agent_model: str = "openai:gpt-4o-mini",
    analysis_type: str = "comprehensive",
    api_keys_json: str = "{}"
) -> str:
    """Analyze market for a given symbol"""
    try:
        # Parse API keys and set environment variables
        api_keys = json.loads(api_keys_json)
        for key, value in api_keys.items():
            os.environ[key] = value

        # Parse model string
        if ":" in agent_model:
            model_provider, model_name = agent_model.split(":", 1)
        else:
            model_provider = "openai"
            model_name = agent_model

        # Normalize provider name (gemini -> google for Agno)
        normalized_provider = model_provider.lower()
        if normalized_provider == "gemini":
            normalized_provider = "google"

        # Validate API key is configured for the selected provider
        # Check both original and normalized provider names
        required_keys = [
            f"{model_provider.upper()}_API_KEY",
            f"{normalized_provider.upper()}_API_KEY"
        ]
        if not any(key in api_keys and api_keys[key] for key in required_keys):
            return create_response(
                False,
                error=f"API key not configured for {model_provider}. Please configure {model_provider.upper()}_API_KEY or {normalized_provider.upper()}_API_KEY in Settings → LLM Config."
            )

        # Create market analyst agent
        analyst = MarketAnalystAgent(
            model_provider=normalized_provider,
            model_name=model_name,
            symbols=[symbol]
        )

        # Run analysis
        result = analyst.analyze_market(symbol, analysis_type)

        return create_response(True, result)
    except Exception as e:
        return create_response(False, error=str(e))


def generate_trade_signal_command(
    symbol: str,
    strategy: str = "momentum",
    agent_model: str = "anthropic:claude-sonnet-4",
    market_data: Optional[str] = None,
    api_keys_json: str = "{}"
) -> str:
    """Generate trading signal"""
    try:
        # Parse API keys and set environment variables
        api_keys = json.loads(api_keys_json)
        for key, value in api_keys.items():
            os.environ[key] = value

        # Parse model string
        if ":" in agent_model:
            model_provider, model_name = agent_model.split(":", 1)
        else:
            model_provider = "anthropic"
            model_name = agent_model

        # Normalize provider name (gemini -> google for Agno)
        normalized_provider = model_provider.lower()
        if normalized_provider == "gemini":
            normalized_provider = "google"

        # Validate API key is configured for the selected provider
        required_keys = [
            f"{model_provider.upper()}_API_KEY",
            f"{normalized_provider.upper()}_API_KEY"
        ]
        if not any(key in api_keys and api_keys[key] for key in required_keys):
            return create_response(
                False,
                error=f"API key not configured for {model_provider}. Please configure {model_provider.upper()}_API_KEY or {normalized_provider.upper()}_API_KEY in Settings → LLM Config."
            )

        # Create trading strategy agent
        strategist = TradingStrategyAgent(
            model_provider=normalized_provider,
            model_name=model_name,
            symbols=[symbol]
        )

        # Generate signal
        result = strategist.generate_trade_signal(symbol, strategy)

        return create_response(True, result)
    except Exception as e:
        return create_response(False, error=str(e))


def create_alpha_competition_command(
    competition_name: str,
    models_json: str,  # JSON array of {name, provider, model_id}
    symbol: str = "BTC/USD",
    mode: str = "baseline",
    api_keys_json: str = "{}"
) -> str:
    """Create Alpha Arena competition"""
    try:
        print(f"[DEBUG] create_alpha_competition_command called", file=sys.stderr)
        print(f"[DEBUG] Name: {competition_name}", file=sys.stderr)
        print(f"[DEBUG] Models JSON: {models_json}", file=sys.stderr)
        print(f"[DEBUG] Symbol: {symbol}", file=sys.stderr)
        print(f"[DEBUG] Mode: {mode}", file=sys.stderr)
        print(f"[DEBUG] API Keys JSON length: {len(api_keys_json)}", file=sys.stderr)

        # Parse API keys and set environment variables
        api_keys = json.loads(api_keys_json)
        print(f"[DEBUG] API keys parsed: {list(api_keys.keys())}", file=sys.stderr)

        for key, value in api_keys.items():
            if value:  # Only set if value is not empty
                os.environ[key] = value
                print(f"[DEBUG] Set env var: {key} (length: {len(value)})", file=sys.stderr)

        # Parse models
        models_data = json.loads(models_json)
        print(f"[DEBUG] Parsed {len(models_data)} models", file=sys.stderr)

        # Import from the correct path
        from agno_trading.core.alpha_arena_competition import CompetitionModel, AlphaArenaCompetition

        models = [
            CompetitionModel(
                name=m['name'],
                provider=m['provider'],
                model_id=m['model_id']
            )
            for m in models_data
        ]
        print(f"[DEBUG] Created {len(models)} CompetitionModel objects", file=sys.stderr)

        competition_id = f"comp_{int(datetime.now().timestamp())}"
        print(f"[DEBUG] Competition ID: {competition_id}", file=sys.stderr)

        # Store competition globally
        global _active_competition
        print(f"[DEBUG] Creating AlphaArenaCompetition instance...", file=sys.stderr)
        _active_competition = AlphaArenaCompetition(
            competition_id=competition_id,
            models=models,
            symbol=symbol,
            mode=mode,
            cycle_interval=150  # 2.5 minutes
        )
        print(f"[DEBUG] AlphaArenaCompetition instance created successfully", file=sys.stderr)

        # Save configuration to database for persistence (with API keys)
        _save_competition_config(competition_id, competition_name, models_data, symbol, mode, api_keys_json)

        return create_response(True, {
            "competition_id": competition_id,
            "status": "created",
            "models": [m['name'] for m in models_data],
            "symbol": symbol,
            "mode": mode
        })

    except Exception as e:
        print(f"[ERROR] create_alpha_competition_command failed: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        return create_response(False, error=str(e))


def start_competition_command(competition_id: str, num_cycles: Optional[int] = None) -> str:
    """Start competition (runs one cycle immediately, then continues)"""
    try:
        print(f"[DEBUG] start_competition_command called with ID: {competition_id}", file=sys.stderr)

        # IMPORTANT: Pass competition_id to restore from database if needed
        competition = _get_or_create_competition(competition_id)

        print(f"[DEBUG] Competition object: {competition}", file=sys.stderr)
        if competition is None:
            print(f"[DEBUG] Competition is None! Checking cache file...", file=sys.stderr)
            config = _load_competition_config(competition_id)
            print(f"[DEBUG] Loaded config: {config}", file=sys.stderr)
            return create_response(False, error=f"No competition found with ID: {competition_id}. Please recreate it.")

        print(f"[DEBUG] Running cycle for competition: {competition.competition_id}", file=sys.stderr)
        print(f"[DEBUG] Competition has {len(competition.models)} models", file=sys.stderr)

        # Run one cycle immediately
        import asyncio
        result = asyncio.run(competition.run_cycle())

        print(f"[DEBUG] Cycle completed successfully", file=sys.stderr)
        return create_response(True, {
            "status": "running",
            "cycle_result": result
        })

    except Exception as e:
        print(f"[DEBUG] Exception in start_competition_command: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        return create_response(False, error=str(e))


def run_cycle_command(competition_id: str) -> str:
    """Run a single competition cycle"""
    try:
        print(f"[DEBUG] run_cycle_command called with ID: {competition_id}", file=sys.stderr)
        competition = _get_or_create_competition(competition_id)

        if competition is None:
            return create_response(False, error="No active competition. Create one first.")

        print(f"[DEBUG] Running cycle for competition: {competition.competition_id}", file=sys.stderr)
        import asyncio
        result = asyncio.run(competition.run_cycle())

        print(f"[DEBUG] Cycle completed successfully", file=sys.stderr)
        return create_response(True, {
            "cycle_result": result,
            "status": "cycle_completed"
        })
    except Exception as e:
        print(f"[DEBUG] Exception in run_cycle_command: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        return create_response(False, error=str(e))


def get_leaderboard_command(competition_id: str) -> str:
    """Get current leaderboard from database state"""
    try:
        db = _get_db_manager()

        # Load competition config
        config = db.get_active_competition()
        if not config:
            return create_response(False, error="No active competition")

        # Load model states from database
        model_states = db.get_model_states(config['competition_id'])

        if not model_states:
            # Return empty leaderboard if no states saved yet
            return create_response(True, {
                "leaderboard": [],
                "cycle_count": 0
            })

        # Get current BTC price for portfolio valuation
        try:
            from agno_trading.tools.kraken_api import get_kraken_api
            kraken = get_kraken_api()
            ticker = kraken.get_ticker("XBTUSD")
            current_price = ticker.get('price', 0)
        except Exception as e:
            print(f"[WARN] Could not get current price: {e}", file=sys.stderr)
            current_price = 0

        leaderboard = []
        for state in model_states:
            positions = json.loads(state['positions_json']) if state['positions_json'] else {}
            capital = state['capital']
            trades_count = state['trades_count']

            # Calculate portfolio value
            portfolio_value = capital
            for symbol, pos in positions.items():
                portfolio_value += pos.get('quantity', 0) * current_price

            initial_capital = 10000.0
            pnl = portfolio_value - initial_capital
            return_pct = (pnl / initial_capital) * 100 if initial_capital > 0 else 0

            leaderboard.append({
                "model": state['model_name'],
                "pnl": pnl,
                "return_pct": return_pct,
                "portfolio_value": portfolio_value,
                "cash": capital,
                "trades": trades_count,
                "positions": len(positions)
            })

        # Sort by P&L descending
        leaderboard.sort(key=lambda x: x['pnl'], reverse=True)

        return create_response(True, {
            "leaderboard": leaderboard,
            "cycle_count": len(model_states)  # Approximate cycle count
        })

    except Exception as e:
        print(f"[ERROR] get_leaderboard_command: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        return create_response(False, error=str(e))


def get_model_decisions_command(competition_id: str, model_name: Optional[str] = None) -> str:
    """Get model decisions/chat feed from database"""
    try:
        db = _get_db_manager()

        # Get decisions from database (persisted across process invocations)
        if model_name and model_name.strip():
            # Get decisions for specific model
            raw_decisions = db.get_recent_decisions(limit=20, agent_id=competition_id)
            decisions = [d for d in raw_decisions if d.get('model') == model_name]
        else:
            # Get decisions for all models in this competition
            raw_decisions = db.get_recent_decisions(limit=50, agent_id=competition_id)
            decisions = raw_decisions

        # Parse the decision JSON stored in the decision column
        parsed_decisions = []
        for d in decisions:
            try:
                decision_data = json.loads(d.get('decision', '{}'))
                decision_data['model'] = d.get('model', 'unknown')
                decision_data['reasoning'] = d.get('reasoning', decision_data.get('reasoning', ''))
                decision_data['confidence'] = d.get('confidence', decision_data.get('confidence', 0))
                parsed_decisions.append(decision_data)
            except json.JSONDecodeError:
                # Use raw data if JSON parsing fails
                parsed_decisions.append({
                    'model': d.get('model', 'unknown'),
                    'action': 'unknown',
                    'reasoning': d.get('reasoning', ''),
                    'confidence': d.get('confidence', 0),
                    'timestamp': d.get('timestamp', 0)
                })

        return create_response(True, {
            "decisions": parsed_decisions,
            "total": len(parsed_decisions)
        })

    except Exception as e:
        print(f"[ERROR] get_model_decisions_command: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        return create_response(False, error=str(e))


def stop_competition_command(competition_id: str) -> str:
    """Stop active competition"""
    try:
        competition = _get_or_create_competition()

        if competition is None:
            return create_response(False, error="No active competition")

        competition.stop()
        final_leaderboard = competition.get_leaderboard()

        # Remove cache file
        if os.path.exists(_competition_cache_file):
            os.remove(_competition_cache_file)

        return create_response(True, {
            "status": "stopped",
            "final_leaderboard": final_leaderboard,
            "total_cycles": competition.cycle_count
        })

    except Exception as e:
        return create_response(False, error=str(e))


# Global competition instance
_active_competition = None

# Get database manager for persistent storage
def _get_db_manager():
    """Get database manager instance"""
    from agno_trading.db.database_manager import get_db_manager
    return get_db_manager()

def _save_api_keys(api_keys: dict):
    """Save API keys - now stored as part of competition config in DB"""
    # API keys are now stored with competition config in database
    # Just set environment variables for current session
    for key, value in api_keys.items():
        if value:
            os.environ[key] = value
    print(f"[DEBUG] API keys set in environment: {list(api_keys.keys())}", file=sys.stderr)

def _load_api_keys_from_db(competition_id: str = None):
    """Load API keys from database and set environment variables"""
    try:
        db = _get_db_manager()

        # If competition_id provided, get keys from that competition
        if competition_id:
            config = db.get_competition_config(competition_id)
        else:
            # Get from active competition
            config = db.get_active_competition()

        if config and config.get('api_keys_json'):
            api_keys = json.loads(config['api_keys_json'])
            for key, value in api_keys.items():
                if value:
                    os.environ[key] = value
            print(f"[DEBUG] Loaded API keys from DB: {list(api_keys.keys())}", file=sys.stderr)
            return api_keys
        return {}
    except Exception as e:
        print(f"[WARN] Failed to load API keys from DB: {e}", file=sys.stderr)
        return {}

def _save_competition_config(competition_id: str, name: str, models_data: list, symbol: str, mode: str, api_keys_json: str = "{}"):
    """Save competition configuration to database"""
    try:
        db = _get_db_manager()
        models_json = json.dumps(models_data)
        db.save_competition_config(competition_id, name, models_json, symbol, mode, api_keys_json)
        print(f"[DEBUG] Competition config saved to database: {competition_id}", file=sys.stderr)
    except Exception as e:
        print(f"[WARN] Failed to save competition config: {e}", file=sys.stderr)

def _load_competition_config(competition_id: str = None):
    """Load competition configuration from database"""
    try:
        db = _get_db_manager()

        if competition_id:
            config = db.get_competition_config(competition_id)
        else:
            config = db.get_active_competition()

        if config:
            # Parse models JSON
            config['models'] = json.loads(config['models_json'])
            print(f"[DEBUG] Competition config loaded from DB: {config['competition_id']}", file=sys.stderr)
            return config
        print(f"[DEBUG] No competition config found in DB", file=sys.stderr)
        return None
    except Exception as e:
        print(f"[WARN] Failed to load competition config: {e}", file=sys.stderr)
        return None

def _get_or_create_competition(competition_id: str = None):
    """Get existing competition or recreate from saved config"""
    global _active_competition

    if _active_competition is not None and (competition_id is None or _active_competition.competition_id == competition_id):
        print(f"[DEBUG] Returning existing competition: {_active_competition.competition_id}", file=sys.stderr)
        return _active_competition

    # Try to load from database
    config = _load_competition_config(competition_id)
    if config is None:
        print(f"[DEBUG] No competition config found", file=sys.stderr)
        return None

    # Load API keys from the competition config
    if config.get('api_keys_json'):
        api_keys = json.loads(config['api_keys_json'])
        for key, value in api_keys.items():
            if value:
                os.environ[key] = value
        print(f"[DEBUG] Loaded API keys: {list(api_keys.keys())}", file=sys.stderr)

    print(f"[DEBUG] Recreating competition from DB config: {config['competition_id']}", file=sys.stderr)

    # Recreate competition
    from agno_trading.core.alpha_arena_competition import CompetitionModel, AlphaArenaCompetition

    models = [
        CompetitionModel(
            name=m['name'],
            provider=m['provider'],
            model_id=m['model_id']
        )
        for m in config['models']
    ]

    _active_competition = AlphaArenaCompetition(
        competition_id=config['competition_id'],
        models=models,
        symbol=config['symbol'],
        mode=config['mode'],
        cycle_interval=150
    )

    print(f"[DEBUG] Competition recreated successfully", file=sys.stderr)
    return _active_competition


def manage_risk_command(
    portfolio_data: str,
    agent_model: str = "openai:gpt-4",
    risk_tolerance: str = "moderate",
    api_keys_json: str = "{}"
) -> str:
    """Run risk management analysis"""
    try:
        # Parse API keys and set environment variables
        api_keys = json.loads(api_keys_json)
        for key, value in api_keys.items():
            os.environ[key] = value

        portfolio = json.loads(portfolio_data)

        # Parse model string
        if ":" in agent_model:
            model_provider, model_name = agent_model.split(":", 1)
        else:
            model_provider = "openai"
            model_name = agent_model

        # Normalize provider name (gemini -> google for Agno)
        normalized_provider = model_provider.lower()
        if normalized_provider == "gemini":
            normalized_provider = "google"

        # Validate API key is configured for the selected provider
        required_keys = [
            f"{model_provider.upper()}_API_KEY",
            f"{normalized_provider.upper()}_API_KEY"
        ]
        if not any(key in api_keys and api_keys[key] for key in required_keys):
            return create_response(
                False,
                error=f"API key not configured for {model_provider}. Please configure {model_provider.upper()}_API_KEY or {normalized_provider.upper()}_API_KEY in Settings → LLM Config."
            )

        # Create risk manager agent
        risk_manager = RiskManagerAgent(
            model_provider=normalized_provider,
            model_name=model_name,
            risk_tolerance=risk_tolerance
        )

        # Run risk analysis
        positions = portfolio.get("positions", [])
        portfolio_value = portfolio.get("total_value", 10000.0)

        result = risk_manager.analyze_portfolio_risk(positions, portfolio_value)

        return create_response(True, result)
    except Exception as e:
        return create_response(False, error=str(e))


def get_config_template_command(config_type: str = "default") -> str:
    """Get configuration template"""
    try:
        if config_type == "default":
            config = AgnoConfig()
        elif config_type == "conservative":
            config = AgnoConfig(
                trading=TradingConfig(
                    mode=TradingMode.PAPER,
                    max_position_size=0.05,
                    max_leverage=1.0,
                    stop_loss_pct=0.03,
                    take_profit_pct=0.10
                )
            )
        elif config_type == "aggressive":
            config = AgnoConfig(
                trading=TradingConfig(
                    mode=TradingMode.PAPER,
                    max_position_size=0.20,
                    max_leverage=2.0,
                    stop_loss_pct=0.08,
                    take_profit_pct=0.25
                )
            )
        else:
            return create_response(False, error=f"Unknown config type: {config_type}")

        return create_response(True, {"config": config.to_dict()})
    except Exception as e:
        return create_response(False, error=str(e))


# ============================================================================
# NEW COMMANDS: Auto-Trading, Debate, Evolution
# ============================================================================

def execute_trade_command(
    signal_json: str,
    portfolio_json: str,
    agent_id: str,
    model: str,
    api_keys_json: str = "{}"
) -> str:
    """Execute a trade based on signal"""
    try:
        from agno_trading.core.trade_executor import get_trade_executor

        signal = json.loads(signal_json)
        portfolio = json.loads(portfolio_json)
        api_keys = json.loads(api_keys_json)

        # Set API keys
        for key, value in api_keys.items():
            os.environ[key] = value

        executor = get_trade_executor()
        result = executor.execute_trade(signal, portfolio, agent_id, model, paper_trading=True)

        return create_response(True, result)
    except Exception as e:
        return create_response(False, error=str(e))


def close_position_command(trade_id: int, exit_price: float, reason: str = "manual") -> str:
    """Close an open position"""
    try:
        from agno_trading.core.trade_executor import get_trade_executor

        executor = get_trade_executor()
        result = executor.close_position(int(trade_id), float(exit_price), reason)

        return create_response(True, result)
    except Exception as e:
        return create_response(False, error=str(e))


def get_agent_trades_command(agent_id: str, limit: int = 100, status: str = None) -> str:
    """Get trade history for an agent"""
    try:
        from agno_trading.db.database_manager import get_db_manager

        db = get_db_manager()
        trades = db.get_agent_trades(agent_id, int(limit), status)

        return create_response(True, {"trades": trades})
    except Exception as e:
        return create_response(False, error=str(e))


def get_agent_performance_command(agent_id: str) -> str:
    """Get performance metrics for an agent"""
    try:
        from agno_trading.db.database_manager import get_db_manager

        db = get_db_manager()
        performance = db.get_agent_performance(agent_id)

        if performance:
            return create_response(True, {"performance": performance})
        else:
            return create_response(False, error="Agent performance not found")
    except Exception as e:
        return create_response(False, error=str(e))


def get_db_leaderboard_command(limit: int = 20) -> str:
    """Get leaderboard from database"""
    try:
        from agno_trading.db.database_manager import get_db_manager

        db = get_db_manager()
        leaderboard = db.get_leaderboard(int(limit))

        return create_response(True, {"leaderboard": leaderboard})
    except Exception as e:
        return create_response(False, error=str(e))


def get_db_decisions_command(limit: int = 50, agent_id: str = None) -> str:
    """Get recent decisions from database"""
    try:
        from agno_trading.db.database_manager import get_db_manager

        db = get_db_manager()
        decisions = db.get_recent_decisions(int(limit), agent_id)

        return create_response(True, {"decisions": decisions})
    except Exception as e:
        return create_response(False, error=str(e))


def run_debate_command(
    symbol: str,
    market_data_json: str,
    bull_model: str,
    bear_model: str,
    analyst_model: str,
    api_keys_json: str = "{}"
) -> str:
    """Run a Bull/Bear/Analyst debate"""
    try:
        from agno_trading.core.debate_orchestrator import get_debate_orchestrator

        market_data = json.loads(market_data_json)
        api_keys = json.loads(api_keys_json)

        # Set API keys
        for key, value in api_keys.items():
            os.environ[key] = value

        orchestrator = get_debate_orchestrator()
        result = orchestrator.run_debate(
            symbol,
            market_data,
            bull_model,
            bear_model,
            analyst_model,
            api_keys
        )

        return create_response(True, result)
    except Exception as e:
        return create_response(False, error=str(e))


def get_recent_debates_command(limit: int = 10) -> str:
    """Get recent debate sessions"""
    try:
        from agno_trading.db.database_manager import get_db_manager

        db = get_db_manager()
        debates = db.get_recent_debates(int(limit))

        return create_response(True, {"debates": debates})
    except Exception as e:
        return create_response(False, error=str(e))


def evolve_agent_command(
    agent_id: str,
    model: str,
    current_instructions_json: str,
    trigger: str,
    notes: str = None
) -> str:
    """Evolve an agent based on performance"""
    try:
        from agno_trading.core.agent_evolution import get_agent_evolution

        current_instructions = json.loads(current_instructions_json)

        evolution = get_agent_evolution()
        result = evolution.evolve_agent(agent_id, model, current_instructions, trigger, notes)

        return create_response(True, result)
    except Exception as e:
        return create_response(False, error=str(e))


def check_evolution_command(agent_id: str) -> str:
    """Check if agent should evolve"""
    try:
        from agno_trading.core.agent_evolution import get_agent_evolution
        from agno_trading.db.database_manager import get_db_manager

        db = get_db_manager()
        performance = db.get_agent_performance(agent_id)

        if not performance:
            return create_response(False, error="Agent performance not found")

        evolution = get_agent_evolution()
        should_evolve, trigger = evolution.should_evolve(agent_id, performance)

        return create_response(True, {
            "should_evolve": should_evolve,
            "trigger": trigger,
            "performance": performance
        })
    except Exception as e:
        return create_response(False, error=str(e))


def get_evolution_summary_command(agent_id: str) -> str:
    """Get evolution summary for an agent"""
    try:
        from agno_trading.core.agent_evolution import get_agent_evolution

        evolution = get_agent_evolution()
        summary = evolution.get_evolution_summary(agent_id)

        return create_response(True, summary)
    except Exception as e:
        return create_response(False, error=str(e))


def enable_auto_trading_command(enabled: str = "true") -> str:
    """Enable or disable auto-trading"""
    try:
        orchestrator = get_global_orchestrator()
        is_enabled = enabled.lower() == "true"
        result = orchestrator.enable_auto_trading(is_enabled)
        return create_response(True, result)
    except Exception as e:
        return create_response(False, error=str(e))


def update_market_price_command(symbol: str, price: str) -> str:
    """Update market price for a symbol"""
    try:
        orchestrator = get_global_orchestrator()
        price_float = float(price)
        orchestrator.update_market_price(symbol, price_float)
        return create_response(True, {"symbol": symbol, "price": price_float})
    except Exception as e:
        return create_response(False, error=str(e))


def execute_signal_command(model: str, signal_json: str, current_price: str) -> str:
    """Execute a trade signal for a model"""
    try:
        import json
        orchestrator = get_global_orchestrator()
        signal = json.loads(signal_json)
        price = float(current_price)

        position = orchestrator.execute_signal(model, signal, price)
        return create_response(True, {"position": position})
    except Exception as e:
        return create_response(False, error=str(e))


def run_continuous_competition_command(
    team_id: str,
    symbol: str,
    interval_seconds: str = "300",
    duration_hours: str = "24"
) -> str:
    """Run continuous competition with auto-trading"""
    try:
        import asyncio
        orchestrator = get_global_orchestrator()

        interval = int(interval_seconds)
        duration = int(duration_hours)

        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        result = loop.run_until_complete(
            orchestrator.run_continuous_competition(team_id, symbol, interval, duration)
        )

        return create_response(True, result)
    except Exception as e:
        return create_response(False, error=str(e))


# Command dispatcher
COMMANDS = {
    "list_models": list_models_command,
    "recommend_model": recommend_model_command,
    "validate_config": validate_config_command,
    "create_agent": create_agent_command,
    "run_agent": run_agent_command,
    "analyze_market": analyze_market_command,
    "generate_trade_signal": generate_trade_signal_command,
    "manage_risk": manage_risk_command,
    "get_config_template": get_config_template_command,
    # Alpha Arena Competition
    "create_competition": create_alpha_competition_command,
    "start_competition": start_competition_command,
    "run_cycle": run_cycle_command,
    "get_leaderboard_alpha": get_leaderboard_command,
    "get_model_decisions_alpha": get_model_decisions_command,
    "stop_competition": stop_competition_command,
    # Trade execution
    "execute_trade": execute_trade_command,
    "close_position": close_position_command,
    "get_agent_trades": get_agent_trades_command,
    "get_agent_performance": get_agent_performance_command,
    "get_db_leaderboard": get_db_leaderboard_command,
    "get_db_decisions": get_db_decisions_command,
    # Competition features
    "enable_auto_trading": enable_auto_trading_command,
    "update_market_price": update_market_price_command,
    "execute_signal": execute_signal_command,
    "run_continuous_competition": run_continuous_competition_command,
    # Debate & evolution
    "run_debate": run_debate_command,
    "get_recent_debates": get_recent_debates_command,
    "evolve_agent": evolve_agent_command,
    "check_evolution": check_evolution_command,
    "get_evolution_summary": get_evolution_summary_command,
}


def main():
    """Main entry point for CLI usage"""
    if len(sys.argv) < 2:
        print(create_response(False, error="No command specified"))
        sys.exit(1)

    command = sys.argv[1]
    args = sys.argv[2:]

    if command not in COMMANDS:
        print(create_response(False, error=f"Unknown command: {command}"))
        sys.exit(1)

    try:
        # Call command function with args
        result = COMMANDS[command](*args)
        print(result)
    except TypeError as e:
        print(create_response(False, error=f"Invalid arguments for command '{command}': {str(e)}"))
        sys.exit(1)
    except Exception as e:
        print(create_response(False, error=f"Command execution failed: {str(e)}"))
        sys.exit(1)


if __name__ == "__main__":
    main()
